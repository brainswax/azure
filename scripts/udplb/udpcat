#! /usr/bin/env python3
import socket
import sys
import argparse
import time
import datetime
import os

def main():
    # Set up argument parser
    parser = argparse.ArgumentParser(description="UDP client similar to netcat")
    parser.add_argument("host", help="Server IP address or hostname")
    parser.add_argument("port", type=int, help="Server port number")
    parser.add_argument("-w", "--timeout", type=int, default=1000,
                       help="Timeout in milliseconds for receiving response (default: 1000)")
    parser.add_argument("-c", "--count", type=int, default=1,
                       help="Number of UDP messages to send (0 for indefinite, default: 1)")
    parser.add_argument("-i", "--interval", type=int, default=1000,
                       help="Interval between messages in milliseconds (default: 1000)")
    parser.add_argument("-l", "--logfile", nargs='?', const="udpcat.log",
                       help="File to log responses with timestamps (default: udpcat.log)")

    # Parse arguments
    args = parser.parse_args()
    host = args.host
    port = args.port
    timeout = args.timeout / 1000.0  # Convert milliseconds to seconds
    count = args.count
    interval = args.interval / 1000.0  # Convert milliseconds to seconds
    logfile = args.logfile  # None if -l not specified, else udpcat.log or user-specified file

    # Read message from standard input, use empty string if none provided
    input_message = sys.stdin.read().strip() if not sys.stdin.isatty() else ""

    # Create UDP socket
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.settimeout(timeout)  # Set timeout for receiving response
        # Bind to a random available local port to maintain the same source port
        sock.bind(('0.0.0.0', 0))
        local_port = sock.getsockname()[1]  # Get the assigned local port
    except socket.error as e:
        print(f"Error creating socket: {e}", file=sys.stderr)
        sys.exit(1)

    # Send messages
    sent_count = 0
    while count == 0 or sent_count < count:
        try:
            # Use input_message if provided, otherwise use the current counter (starting from 1)
            message = input_message if input_message else str(sent_count + 1)
            # Send message to server
            sock.sendto(message.encode('utf-8'), (host, port))
            print(f"Sent message to {host}:{port} from 0.0.0.0:{local_port}: {message}")

            # Wait for response
            try:
                data, addr = sock.recvfrom(1024)  # Buffer size of 1024 bytes
                response = data.decode('utf-8')
                print(response)  # Print response to stdout
                # Log response with timestamp to file if logfile is specified
                if logfile:
                    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")
                    log_entry = f"[{timestamp}] Received from {addr[0]}:{addr[1]}: {response}\n"
                    with open(logfile, 'a') as f:
                        f.write(log_entry)
            except socket.timeout:
                error_msg = f"No response received within {args.timeout}ms"
                print(error_msg, file=sys.stderr)
                # Log timeout with timestamp if logfile is specified
                if logfile:
                    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")
                    log_entry = f"[{timestamp}] {error_msg}\n"
                    with open(logfile, 'a') as f:
                        f.write(log_entry)
            except socket.error as e:
                error_msg = f"Error receiving response: {e}"
                print(error_msg, file=sys.stderr)
                # Log error with timestamp if logfile is specified
                if logfile:
                    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")
                    log_entry = f"[{timestamp}] {error_msg}\n"
                    with open(logfile, 'a') as f:
                        f.write(log_entry)

            sent_count += 1
            if count == 0 or sent_count < count:
                time.sleep(interval)  # Wait before sending next message
        except socket.error as e:
            print(f"Error sending message: {e}", file=sys.stderr)
            # Log send error with timestamp if logfile is specified
            if logfile:
                timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")
                log_entry = f"[{timestamp}] Error sending message to {host}:{port}: {e}\n"
                with open(logfile, 'a') as f:
                    f.write(log_entry)
            break
        except KeyboardInterrupt:
            print("\nStopped by user", file=sys.stderr)
            # Log interrupt with timestamp if logfile is specified
            if logfile:
                timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")
                log_entry = f"[{timestamp}] Stopped by user\n"
                with open(logfile, 'a') as f:
                    f.write(log_entry)
            break

    sock.close()

if __name__ == "__main__":
    main()
